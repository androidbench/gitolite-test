<p><head><style>
    body        { margin-left:  40px;   font-size:  0.9em;  font-family: sans-serif; max-width: 800px; }
    h1          { background: #ffb; margin-left: -30px;   border-bottom: 5px  solid #ccc; }
    h2, h3      { background: #ffb; margin-left: -30px;   border-top:    3px  solid #ddd; }
    h4, h5      { background: #ffb; margin-left: -20px; }
    code        { font-size:    1.1em;  background:  #ddf; }
    pre         { margin-left:  2em;    background:  #ddf; }
    pre code    { font-size:    1.1em;  background:  #ddf; }
</style></head></p>

<h2>admin defined commands</h2>

<p>Summary: this document describes a mechanism to allow users controlled access
to specific programs or scripts, without giving them full shell access.</p>

<p><strong>WARNING</strong>: careless use of this feature, including inadequate review of
allowed commands or scripts, could compromise this security and allow users to
grant themselves full shell access, accidentally or otherwise.</p>

<hr />

<p>In this document:</p>

<ul>
<li><a href="#_background">background</a></li>
<li><a href="#_setting_it_up">setting it up</a>
<ul>
<li><a href="#_configuring_ADCs">configuring ADCs</a></li>
</ul></li>
<li><a href="#_anatomy_of_a_command">anatomy of a command</a></li>
<li><a href="#_example_uses_and_sample_commands_in_contrib">example uses and sample commands in contrib</a>
<ul>
<li><a href="#_fork">fork</a></li>
<li><a href="#_deleting_trashing_repos">deleting/trashing repos</a></li>
<li><a href="#_enable_disable_push_access_temporarily">enable/disable push access temporarily</a></li>
<li><a href="#_bonus_restricted_admin">(bonus) restricted admin</a></li>
</ul></li>
<li><a href="#_how_this_feature_came_about">how this feature came about</a></li>
</ul>

<hr />

<p><a name="_background"></a></p>

<h3>background</h3>

<p>Allowing users to get a shell is a no-no if you're using gitolite, but there
are times when you want them to be able to run specific commands or custom
scripts that you (the admin) have pre-approved to be "safe".  Here's how to
enable such commands.</p>

<p>However, as the warning at the top says, careless use could allow users to
defeat this security and get a shell.  Every command you approve must be
checked to be sure it cannot be compromised.</p>

<p>To help you with this, gitolite restricts ADCs arguments to only some very
safe characters (see <code>$ADC_CMD_ARGS_PATT</code> in <code>src/gitolite_rc.pm</code>).  The code
inside the ADC, however, is <em>your</em> responsibility.  The sample ADCs shipped
with gitolite (in <code>contrib/adc</code>) should be OK, but an extra pair of eyes never
hurt :-) so please review before installing them.</p>

<p><font color="gray"></p>

<p>Finally, although this is a generic way to allow specific commands to be run,
most of the examples and sample ADCs pertain to allowing users to manage their
"own" repos.  If that's your use case, please read
<a href="http://sitaramc.github.com/gitolite/doc/wildcard-repositories.html">doc/wildcard-repositories.mkd</a> before you continue here.</p>

<p></font></p>

<p><a name="_setting_it_up"></a></p>

<h3>setting it up</h3>

<p>This can only be setup by someone who has shell access to the server.  Edit
the rc file and update the <code>$GL_ADC_PATH</code> variable to point to, say,
<code>/home/git/bin/adc</code>.  <em>Nothing happens unless this variable is set and
pointing to a directory</em>.  Then put in whatever such commands you create into
that directory.  If you have a command called "foo" in that directory, then a
user can invoke it by saying:</p>

<pre><code>ssh git@server foo argument list
</code></pre>

<p><strong>WARNING: When gitolite takes control, this directory is checked first, and
if the requested command exists, it is executed.  It is therefore quite easy
to inadvertently <em>hide</em> some of the "official" commands (like "info",
"expand", "setperms", etc., or worse, say "git-upload-pack"!) by creating
executable files with those names in this directory.  So don't do that -- you
have been warned!</strong></p>

<p><a name="_configuring_ADCs"></a></p>

<h4>configuring ADCs</h4>

<p>I didn't want to put configuration variables for ADCs also into the main 'rc'
file, so I chose to put them in the <code>adc.common-functions</code> file instead.  Take
a look at it sometime.</p>

<p><a name="_anatomy_of_a_command"></a></p>

<h3>anatomy of a command</h3>

<p>You can basically do whatever you want in such a command -- go wild!  It's
upto you to check the permissions of <em>each</em> repo that the user is manipulating
using your command -- you can <code>rm -rf $GL_REPO_BASE_ABS</code> if you like and
gitolite wouldn't stop you.</p>

<p>The current directory (<code>$PWD</code>) will be set to the <code>$HOME</code> of <code>git@server</code> (or
whatever id you're using).  It won't be any specific repo, it won't even be
the base directory of all the repos.</p>

<p>Gitolite defines a few environment variables, as well as allows you to
directly query the ownership and access permissions of any repository.</p>

<p>The environment variables available are:</p>

<ul>
<li><code>GL_USER</code> -- the name of the user invoking the command</li>
<li><code>GL_BINDIR</code> -- the directory containing all the binaries (in particular,
<code>gitolite.pm</code>, which is all we really care about here)</li>
<li><code>GL_REPO_BASE_ABS</code> -- the absolute path of the base directory containing
all the repos</li>
</ul>

<p>There are a few other variables also available but the above are the only ones
you should rely on.  Please treat any other variables you notice as being
internal/undocumented/subject to change.</p>

<p>[Implementation note: some of the distro packagers don't seem to like
<code>GL_BINDIR</code>.  I have not tested this in those scenarios, but they probably put
<code>gitolite.pm</code> somewhere in perl's lib path anyway, so it ought to work].</p>

<p>In addition, all the arguments of the command are also available to you, so
you can define your own command syntaxes.  Gitolite checks these arguments to
make sure they fit a very conservative pattern (see <code>$ADC_CMD_ARGS_PATT</code> in
<code>src/gitolite.pm</code>), so take that into consideration when designing your
commands and usage.</p>

<p>Finally, you can call gitolite to query ownership and permissions for the
current user (which may not necessarily be the owner).  This is done loosely
as follows (don't use this exact code yet though):</p>

<pre><code>perl -I$GL_BINDIR -Mgitolite -e "cli_repo_rights('reponame')"
</code></pre>

<p>which will print two space-separated words: permissions and owner.  Something
like <code>_____R__W u1</code> or maybe <code>____@R_@W &lt;gitolite&gt;</code>.  (The <code>u1</code> indicates the
queried repo is a wildcard repo created by user <code>u1</code>; for meanings of the "@"
see doc/report-output.mkd)</p>

<p>But that's cumbersome.  There's a bash shell function called
<code>get_rights_and_owner</code> in <code>contrib/adc/adc.common-functions</code> that is much more
convenient.  See any of the other samples for how to use it.</p>

<p>If you don't like this, roll your own.  If you don't like bash, do the eqvt in
your language of choice.</p>

<p><a name="_example_uses_and_sample_commands_in_contrib"></a></p>

<h3>example uses and sample commands in contrib</h3>

<p><a name="_fork"></a></p>

<h4>fork</h4>

<p>A user would use the fork command like this:</p>

<pre><code>ssh git@server fork from to
</code></pre>

<p>where "from" is a repo to which the user invoking the fork has "R" access, and
"to" is a repo that does not yet exist and to which he has "C" access.</p>

<p>(Reminder: these access checks are done by the "fork" script, <strong>not</strong> within
gitolite -- once again, you are responsible for making sure your scripts
maintain the security of the system!)</p>

<p>Strictly speaking this command is not really needed.  Even without all this
"admin-defined commands" setup you could still do the following, purely from
the client side:</p>

<pre><code>git clone git@server:from
cd from
git remote add new git@server:to
git push new refs/*:refs/*
</code></pre>

<p>or some such incantation.</p>

<p><a name="rmrepo"></a></p>

<p><a name="_deleting_trashing_repos"></a></p>

<h4>deleting/trashing repos</h4>

<p>See the <a href="http://sitaramc.github.com/gitolite/contrib/adc/repo-deletion.html">repo-deletion document</a> for details about this.</p>

<p><a name="_enable_disable_push_access_temporarily"></a></p>

<h4>enable/disable push access temporarily</h4>

<p>If you want to disable push access to gitolite temporarily (maybe for
maintenance), anyone with write access to the gitolite-admin repo can do this:</p>

<pre><code>ssh git@server able dis @all    # able dis ==&gt; dis able
</code></pre>

<p>To re-enable after the maint work is done:</p>

<pre><code>ssh git@server able en @all     # able en ==&gt; en able
</code></pre>

<p>You can also do this for one or more individual repos; in place of <code>@all</code>,
just use a space separated list of reponames (exactly as they would appear in
the config file).  Wildcards are not supported; patches welcome ;-)</p>

<p>Note: please see <a href="http://sitaramc.github.com/gitolite/doc/3-faq-tips-etc.html#_disabling_write_access_to_take_backups">this</a> for more on this.</p>

<p><a name="_bonus_restricted_admin"></a></p>

<h4>(bonus) restricted admin</h4>

<p>It's rather important to me (and presumably others in the "corporate" world)
to separate permission to push to the "gitolite-admin" repo from unrestricted
shell access to the server.  This issue has been visited often in the past.</p>

<p>Until now, though, this was binary -- you either had full shell access or none
at all.  If there were tasks that legitimately needed to be done from the
shell on the server, it often meant you had to break that separation or load
the few people who did have shell access already.</p>

<p>Now, however, it is possible to provide scripts to do what you want, and put
them in <code>$GL_ADC_PATH</code>.  <code>contrib/adc/restrict-admin</code> is a commented sample --
as you can see, it cleverly makes use of the fact that you can now check for
the invoking uses access to any repo in the system.  In this case it checks if
he has "W" access to the gitolite-admin repo, and if he does, allows the
script to proceed.</p>

<p>[Note that this particular use does not require <code>$GL_WILDREPOS</code> to be enabled,
because it's not using any wildcard repos].</p>

<hr />

<p><a name="_how_this_feature_came_about"></a></p>

<h3>how this feature came about</h3>

<p><font color="gray"></p>

<p>Gitolite was named to be short for "gitosis-lite".  Someone now wants to turn
it into a "github-lite" :-) and even had some code to start me off thinking.</p>

<p>Since my first impulse on being asked for a feature is to say no, I was
casting about for a reason when he gave me one: he first made some noises
about perl, then said something about rewriting it all in scheme.  Nice... I
resisted the urge to point him to <a href="http://xkcd.com/224/">this</a>, told him that's a great
idea and he should go for it, mentally blessing him for letting me off the
hook on coding it ;-) <a href="http://c2.com/cgi/wiki?LazinessImpatienceHubris">Laziness</a> <em>is</em> the first virtue you know!</p>

<p>And that was that.  For a couple of days.</p>

<p>Soon, though, I realised that there could be a pretty big bonus in this for
tightly controlled setups, so I went and coded it all anyway.  See the section
on "restricted admin" for what's really exciting about this for <em>me</em>.</p>

<p></font></p>
